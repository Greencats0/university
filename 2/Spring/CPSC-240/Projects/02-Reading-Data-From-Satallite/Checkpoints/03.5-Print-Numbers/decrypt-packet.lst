     1                                  ; taken from here cause I was banging my head against a wall for hours -> https://gist.github.com/BertrandBordage/10921263
     2                                  ; checking if file exists -> https://gist.github.com/Archenoth/5380671
     3                                  ; This program will decrypt a packet from an incoming satallite
     4                                  ; It decrypts the packet in memory so there is no need to write subroutines to reverse the order of the bytes
     5                                  ; Written by Jared Dyreson
     6                                  ; CPSC-240 TR @ 11:30 to 13:20
     7                                  ; uisng printf, kek -> https://gist.github.com/jamichaels/a5e770105615d9e32b18
     8                                  
     9                                  %define SYS_EXIT 60
    10                                  %define SYS_READ 0
    11                                  %define SYS_WRITE 1
    12                                  %define SYS_OPEN 2
    13                                  %define SYS_CLOSE 3
    14                                  %define STDOUT 1
    15                                  %define SYS_CREATE 85
    16                                  
    17                                  %define BUFFER_SIZE 180
    18                                  extern printf
    19                                  
    20                                  section .text
    21                                  global  main
    22                                  main:
    23                                    ; So we can read in our argument from argv[]
    24 00000000 4883C410                  add rsp, byte 0x10
    25 00000004 5F                        pop rdi
    26 00000005 EB00                      jmp _check
    27                                  _check:
    28                                  ; basic if/else control flow -> https://stackoverflow.com/questions/14292903/complex-if-statement-in-assembly
    29 00000007 BA00000000                mov rdx,0
    30 0000000C 4839C2                    cmp rdx,rax
    31 0000000F 7E02                      jle _cont
    32 00000011 7F3C                      jnle _exit_failiure
    33                                    _cont:
    34                                  
    35                                    ; open the file
    36 00000013 B802000000                mov rax, SYS_OPEN
    37 00000018 BE00000000                mov rsi, 0
    38 0000001D 0F05                      syscall
    39 0000001F 48890425[00000000]        mov [fd], rax
    40 00000027 EB00                      jmp _read_write
    41                                  
    42                                  _read_write:
    43                                    ; Read the file into the buffer
    44 00000029 B800000000                mov rax, SYS_READ
    45 0000002E 488B3C25[00000000]        mov rdi, [fd]
    46 00000036 48BE-                     mov rsi, file_buffer
    47 00000038 [0000000000000000] 
    48 00000040 BAB4000000                mov rdx, BUFFER_SIZE
    49 00000045 0F05                      syscall
    50                                  
    51 00000047 4883F800                  cmp rax, 0
    52 0000004B 740E                      je close_file
    53                                  
    54 0000004D 7ADA                      jp _read_write
    55                                  
    56                                  
    57                                  _exit_failiure:
    58                                    ; exit with code 1
    59 0000004F B83C000000                mov rax, 60
    60 00000054 BF01000000                mov rdi, 1
    61 00000059 0F05                      syscall
    62                                  
    63                                  close_file:
    64                                    ; Close the file stream
    65 0000005B B803000000                mov rax, SYS_CLOSE
    66 00000060 48BF-                     mov rdi, fd
    67 00000062 [0000000000000000] 
    68 0000006A 0F05                      syscall
    69                                  
    70 0000006C 4D31C0                    xor r8, r8
    71 0000006F 4831C0                    xor rax, rax
    72                                  
    73 00000072 EB05                      jmp decryptor
    74                                  _reset_key:
    75 00000074 4831C0                    xor rax, rax
    76 00000077 EB00                      jmp decryptor
    77                                  decryptor:
    78                                    ; goal
    79                                    ; xor each byte in the file buffer, given a certain offset to that position in the string in the file_buffer and the key
    80                                    ; reset the key once we reach 9th element
    81                                  
    82                                    ; r8 -> indexing the file_buffer
    83                                    ; rax -> indexing our key
    84                                    ; r11 -> contains our needed variable from the file_buffer
    85                                    ; r12 -> contains our needed variable from the key
    86                                  
    87                                    ; if(r8 >= 180), we need to leave
    88 00000079 4981F8B4000000            cmp r8, 180
    89 00000080 7D42                      jge exit
    90                                  
    91                                    ; if(r9 > 8), we need to reset it
    92 00000082 4883F808                  cmp rax, 8
    93 00000086 7FEC                      jg _reset_key
    94                                  
    95                                    ; load the character from the file_buffer we need into the variable [check]
    96 00000088 488D1C25[00000000]        lea rbx, [file_buffer]
    97 00000090 4E8B1C03                  mov r11, [rbx+(r8*1)] ; variable = buff[i]
    98                                  
    99                                  
   100                                    ; move current offset into the correct register
   101 00000094 488D1C25[02000000]        lea rbx, [key]
   102                                  
   103 0000009C 4883F800                  cmp rax, 0
   104 000000A0 7402                      je other
   105 000000A2 7508                      jne _begin
   106                                    other:
   107 000000A4 41BC36000000              mov r12, 0x36 ; 0th index cannot be accessed for some reason
   108 000000AA EB06                      jmp cont
   109                                    _begin:
   110 000000AC 4C8B24C3                  mov r12, [rbx+(rax*8)]; xor_key_variable = key[index]
   111 000000B0 EB00                      jmp cont
   112                                    cont:
   113 000000B2 4D31E3                    xor r11, r12 ; buf[i] ^ key[index]
   114 000000B5 4D8998[00000000]          mov [file_buffer+r8], r11 ; r11 = buf[i] ^ key[index]
   115 000000BC 49FFC0                    inc r8 ; r8++
   116 000000BF 48FFC0                    inc rax ; rax++
   117 000000C2 EBB5                      jmp decryptor ;loop back
   118                                  
   119                                  exit:
   120                                    ; mov rsi, file_buffer
   121                                    ; mov rdi, format
   122                                    ; xor rax,rax
   123                                    ; call printf
   124 000000C4 48BE-                     mov rsi, file_buffer
   125 000000C6 [0000000000000000] 
   126 000000CE B801000000                mov rax, SYS_WRITE
   127 000000D3 BAB4000000                mov rdx, BUFFER_SIZE
   128 000000D8 BF01000000                mov rdi, 1
   129 000000DD 0F05                      syscall
   130 000000DF B801000000                mov rax, SYS_WRITE
   131 000000E4 48BE-                     mov rsi, endl
   132 000000E6 [4A00000000000000] 
   133 000000EE BF01000000                mov rdi, 1
   134 000000F3 BA01000000                mov rdx, 1
   135 000000F8 0F05                      syscall
   136 000000FA EB00                      jmp leave_segment
   137                                    leave_segment:
   138 000000FC B83C000000                mov rax, 60
   139 00000101 BFB4000000                mov rdi, BUFFER_SIZE
   140 00000106 0F05                      syscall
   141                                  
   142                                  
   143                                  section .data
   144 00000000 0000                    fd dw 0
   145 00000002 360000000000000013-     key: dq 0x36,0x13,0x92,0xa5,0x5a,0x27,0xf3,0x00,0x32
   146 0000000B 000000000000009200-
   147 00000014 000000000000A50000-
   148 0000001D 00000000005A000000-
   149 00000026 000000002700000000-
   150 0000002F 000000F30000000000-
   151 00000038 000000000000000000-
   152 00000041 003200000000000000 
   153 0000004A 0A                      endl: db 10
   154 0000004B 0000000000000000        small_buffer: dq 0
   155 00000053 25730A00                format: db "%s", 10, 0
   156                                  
   157                                  
   158                                  section .bss
   159 00000000 <res 000000B4>          file_buffer resb BUFFER_SIZE
